import zlx.record
from collections import namedtuple

class error (RuntimeError):
    pass

screen_size = namedtuple('screen_size', 'width height'.split())

class message (object):
    '''
    Represents an event generated by a tui driver.
    A driver may derive this or use it as it is.
    '''
    def __init__ (self, name, **kw):
        self.name = name
        for k, v in kw.items():
            setattr(self, k, v)

#* driver *******************************************************************
class driver (object):
    '''
    Input and display driver.
    Derive this to provide an interface I/O.
    '''
    def __init__ (self):
        object.__init__(self)

    def get_screen_size (self):
        raise RuntimeError('must be implemented in derived class')

    def get_message (self):
        '''
        Overload this or else...
        '''
        return message('quit')

# attributes to be used in style (:-D all puns intended)
A_NORMAL = 0
A_BOLD = 1
A_ITALIC = 2
A_ALT_CHARSET = 4

#* style ********************************************************************
class style (zlx.record.Record):
    '''
    Describes the style for a portion of text.
    Instantiate with: style(fg, bg, attr)
    '''
    __slots__ = 'fg bg attr'.split()
    pass

class strip (zlx.record.Record):
    '''
    A strip is a portion of a one line of text with its style.
    '''
strip = zlx.record.make('tui.strip', 'text style col')

def text_width (text):
    return len(text)

#* window *******************************************************************
class window (object):
    '''
    A window has width and height and a list of updates.
    The updates are organized as a list for each row where elements are
    strips.
    '''

    def __init__ (self, width, height, default_style):
        object.__init__(self)
        self.width = width
        self.height = height
        self.default_style = default_style
        self.wipe_updates()

    def wipe_updates (self):
        '''
        Empties the strips from the updates field.
        No need to overload this.
        '''
        self.updates = [[] for i in range(self.height)]

    def write (self, row, col, style, text):
        '''
        Adds the given text in the right place in the updates field.
        No need to overload this.
        '''
        self.updates[row]


    def refresh (self, row, col, width):
        '''
        Refreshes the content a strip of the window.
        Overload this to implement displaying content in your window.
        Normally you want to call write() with text to cover all length
        of the given strip.
        This should ideally not do blocking operations as for good UX it must
        be fast.
        '''
        self.write(row, col, self.default_style, ' ' * width)

    def refresh_area (self, 
            start_row = 0, 
            start_col = 0, 
            height = None, 
            width = None):
        '''
        Calls refresh() for each row in given range.
        if height or width are left None they will cover the window to its
        border.
        No need to overload this.
        '''
        if start_row >= self.height or start_col >= self.width: return

        if height is None: height = self.height
        if width is None: width = self.width

        end_row = min(self.height, start_row + height)
        width = min(self.width - start_col, width)

        for r in range(start_row, end_row):
            self.refresh(r, start_col, width)

    def handle (self, msg):
        '''
        Message handler.
        No need to overload this, instead create/overload methods named
            handle_<message_name>
        '''
        getattr(self, 'handle_' + msg.name)(*l, **kw)

    def fetch_updates (self):
        '''
        Extracts the updates from this window.
        No need to overload this
        '''
        u = self.updates
        self.wipe_updates()
        return u

