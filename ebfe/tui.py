import functools
from collections import namedtuple

import zlx.record
from zlx.io import dmsg

#* saturate *****************************************************************
def saturate (x, min_value, max_value):
    '''
    Returns given x if in range [min_value, max_value] or
    the corresponding range bound closer to x.
    '''
    return max(min(x, max_value), min_value)

def ab_intersects_cd (a, b, c, d):
    return a < d and b > c

def ab_inside_cd (a, b, c, d):
    return a >= c and b <= d

#* error ********************************************************************
class error (RuntimeError):
    def __init__ (self, fmt, *a, **b):
        RuntimeError.__init__(self, fmt.format(*a, **b))

#* app_quit *****************************************************************
class app_quit (error):
    def __init__ (self, ret_code = 0):
        error.__init__(self, 'quit tui app')
        self.ret_code = ret_code

# cursor modes:
CM_NO_UPDATE = -1
CM_INVISIBLE = 0
CM_NORMAL = 1
CM_BIG = 2

# attributes to be used in style (:-D all puns intended)
A_NORMAL = 0
A_BOLD = 1
A_ITALIC = 2
A_ALT_CHARSET = 4

STYLE_PARSE_MAP = dict(
        normal = A_NORMAL,
        bold = A_BOLD,
        italic = A_ITALIC,
        altchar = A_ALT_CHARSET,
        black = 0,
        red = 1,
        green = 2,
        yellow = 3,
        blue = 4,
        magenta = 5,
        cyan = 6,
        grey = 7,
    )

screen_size = namedtuple('screen_size', 'width height'.split())

style_caps = namedtuple('style_caps', 'attr fg_count bg_count fg_default bg_default'.split())

#* message ******************************************************************
class message (object):
    '''
    Represents an event generated by a tui driver.
    A driver may derive this or use it as it is.
    '''
    def __init__ (self, *l, **kw):
        object.__init__(self)
        if l:
            for i in range(len(l)):
                setattr(self, self.__slots__[i], l[i])
        for k, v in kw.items():
            setattr(self, k, v)
# class message - end

#* resize_message ***********************************************************
class resize_message (message):
    __slots__ = 'width height'.split()
    name = 'resize'

#* key_message **************************************************************
class key_message (message):
    __slots__ = 'key'.split()
    name = 'key'

#* driver *******************************************************************
class driver (object):
    '''
    Input and display driver.
    Derive this to provide an interface I/O.
    '''
# driver.__init__()
    def __init__ (self):
        object.__init__(self)

# driver.get_screen_size()
    def get_screen_size (self):
        raise RuntimeError('must be implemented in derived class')

# driver.get_style_caps()
    def get_style_caps (self):
        '''
        Overload this to return the capabilites for styles.
        The function should return a style_caps object
        '''
        return style_caps(A_NORMAL, 1, 1, 0, 0)

# driver.register_styles()
    def register_styles (self, style_map):
        '''
        Processes the given map and for each style calls register_style()
        storing the returned object.
        No need to overload this.

        '''
        self.style_map = {}
        for k, v in style_map.items():
            self.style_map[k] = self.build_style(v)

# driver.build_style()
    def build_style (self, style):
        '''
        Process the tui attributes and colors and generate whatever is needed
        by the driver to display text with those specs.
        Overload this!
        '''
        return style

# driver.get_message()
    def get_message (self):
        '''
        Overload this or else...
        '''
        return message('quit')

# driver.render()
    def render (self, updates):
        '''
        Goes through all update strips and renders them.
        No need to overload this.
        '''
        focus_row = 0
        focus_col = 0
        dmsg('driver: {} updates', len(updates))
        self.prepare_render_text()
        for row, strips in updates.items():
            for s in strips:
                if isinstance(s, cursor_update):
                    self.set_cursor(s.mode, s.row, s.col)
                    continue
                if len(s.text) > 0:
                    self.render_text(s.text, s.style_name, s.col, row)
        self.finish_render_text()

# driver.render_text()
    def render_text (self, text, style_name, column, row):
        '''
        Overload this to output.
        '''
        pass

# driver.prepare_render_text()
    def prepare_render_text (self):
        '''
        Called before rendering text.
        Overload this to do something right before the avalanche of render_text() calls.
        '''
        pass

# driver.finish_render_text()
    def finish_render_text (self):
        '''
        Called after rendering text.
        Overload this to do something after render_text() calls.
        '''
        pass

# driver.set_cursor()
    def set_cursor (self, mode, row, col):
        '''
        Sets cursor position and mode.
        Overload this!
        '''
        pass

# driver.restore_state()
    def restore_state (self):
        '''
        Restores the changed state of the console
        Overload this!
        '''
        pass

# class driver - end


#* style ********************************************************************
class style (zlx.record.Record):
    '''
    Describes the style for a portion of text.
    Instantiate with: style(fg, bg, attr)
    '''
    __slots__ = 'attr fg bg'.split()

#* make_style ***************************************************************
def make_style (caps,
        fg = None, bg = None, attr = A_NORMAL,
        fg256 = None, bg256 = None, attr256 = None):
    '''
    creates a style object that fits within the given caps
    '''
    if caps.fg_count == 256 and fg256 is not None: fg = fg256
    if caps.bg_count == 256 and bg256 is not None: bg = bg256
    if caps.bg_count == 256 and attr256 is not None: attr = attr256
    if fg is None or fg >= caps.fg_count: fg = caps.fg_default
    if bg is None or bg >= caps.bg_count: bg = caps.bg_default
    attr &= caps.attr
    return style(attr, fg, bg)

#* parse_styles *************************************************************
def parse_styles (caps, src):
    m = {}
    for line in src.splitlines():
        if '#' in line: line = line[0:line.index('#')]
        line = line.strip()
        if line == '': continue
        name, *attrs = line.split()
        d = {}
        for a in attrs:
            k, v = a.split('=', 1)
            vparts = (STYLE_PARSE_MAP[x] if x in STYLE_PARSE_MAP else int(x) for x in v.split('|'))
            d[k] = functools.reduce(lambda a, b: a | b, vparts)
        m[name] = make_style(caps, **d)
    return m

#* strip ********************************************************************
strip = zlx.record.make('tui.strip', 'text style_name col')

def split_strip (s, col):
    '''
    returns a tuple of one or two strips by splitting the given strip
    at the given column.
    '''
    w = compute_text_width(s.text)
    if col > s.col and col < s.col + w:
        i = compute_index_of_column(s.text, col - s.col)
        return (strip(s.text[:i], s.style_name, s.col), strip(s.text[i:], s.style_name, col))
    return (s,)

def trim_strips (sl, col, width = None, end_col = None):
    if end_col is None:
        end_col = col + width
    r = []
    for s in sl:
        if s.col >= end_col: break
        strip_end_col = s.col + compute_text_width(s.text)
        if strip_end_col <= col: continue
        if s.col < col:
            s = split_strip(s, col)[1]
        if strip_end_col > end_col:
            s = split_strip(s, end_col)[0]
        r.append(s)
    return r

#* cursor_update ************************************************************
cursor_update = zlx.record.make('tui.cursor_update', 'mode row col')

#* style_update *************************************************************
style_update = zlx.record.make('tui.style_update', 'col width restyler')

#* apply_style_update *******************************************************
def apply_style_update (update_list, col, width, restyler):
    ur = []
    for s in update_list:
        if isinstance(s, cursor_update):
            ur.append(s)
            continue
        w = compute_text_width(s.text)
        if ab_intersects_cd(s.col, s.col + w, col, col + width):
            if ab_inside_cd(s.col, s.col + w, col, col + width):
                s.style_name = restyler(s)
                ur.append(s)
            else:
                l = split_strip(s, col)
                l2 = []
                for i in l:
                    l2.extend(split_strip(i, col + width))
                for s in l2:
                    w = compute_text_width(s.text)
                    if ab_inside_cd(s.col, s.col + w, col, col + width):
                        s.style_name = restyler(s)
                    ur.append(s)
        else:
            ur.append(s)
    return ur

#* compute_text_width *******************************************************
def compute_text_width (text):
    return len(text)

#* compute_index_of_column **************************************************
def compute_index_of_column (text, column):
    '''
    Computes the index in the text corresponding to given column, assuming
    index 0 corresponds to column 0.
    This should take into account the width of unicode chars displayed.
    Returns None if the text does not reach that column.
    '''
    return column

STYLE_BEGIN = '\a'
STYLE_END = '\b'

#* styled_text_chunks *******************************************************
def styled_text_chunks (styled_text, initial_style = 'default'):
    for x in ''.join((initial_style, STYLE_END, styled_text)).split(STYLE_BEGIN):
        style, text = x.split(STYLE_END, 1)
        #if not text: continue
        yield (style, text)

#* strip_styles_from_styled_text ********************************************
def strip_styles_from_styled_text (styled_text):
    return ''.join((x.split(STYLE_END, 1)[1] for x in (STYLE_END + text).split(STYLE_BEGIN)))

#* get_char_width ***********************************************************
def get_char_width (ch):
    return 1

#* compute_styled_text_index_of_column **************************************
def compute_styled_text_index_of_column (styled_text, column):
    '''
    Computes the index in the text corresponding to given column, assuming
    index 0 corresponds to column 0.
    This should take into account the width of unicode chars displayed.
    Returns a pair (index, column). column may be smaller than column if
    the char at index is double-width and would jump over requested column.
    If the string is not as wide to reach the column the function returns
    (None, text_width)
    '''
    c = 0
    text_mode = True
    for i in range(len(styled_text)):
        if text_mode:
            ch = styled_text[i]
            if ch == STYLE_BEGIN:
                text_mode = False
                continue
            w = get_char_width(ch)
            if c + w > column: return i, c
            c += w
        else:
            if styled_text[i] == STYLE_END:
                text_mode = True
    return None, c

#* compute_styled_text_width ************************************************
def compute_styled_text_width (styled_text):
    return compute_styled_text_index_of_column(styled_text, 9999)[1]

#* generate_style_markers ***************************************************/
def generate_style_markers (styles_desc):
    m = {}
    dflt = None
    dflt_value = None
    for s in styles_desc.split():
        if '=' in s: a, b = s.split('=', 1)
        else: a, b = s, s
        if not dflt:
            dflt = a
            dflt_value = b
        m[a] = ''.join((STYLE_BEGIN, b, STYLE_END))
    m[None] = dflt_value
    return m

#* window *******************************************************************
class window (object):
    '''
    A window has width and height and parent where it sends its updates.
    Recommended overloads:
    - various message handlers: handle_xxx() (handle_timeout, handle_char)
    - refresh_strip() - to generate output for a row portion when asked
    - resize() - if the window has children or custom fields need adjusting
    '''

    wid_seed = 0

# window.__init__()
    def __init__ (self,
            wid = None,
            width = 0,
            height = 0,
            styles = 'default',
            active_styles = None,
            can_have_focus = False,
            parent = None):
        object.__init__(self)
        if wid is None:
            wid = '{}_{}'.format(self.__class__.__name__, window.wid_seed)
            window.wid_seed += 1
        self.wid = wid
        self.width = width
        self.height = height
        self.can_have_focus = can_have_focus
        self.in_focus = False
        self.attach(parent)
        self.set_styles(styles, active_styles)

    def attach (self, parent):
        self.parent = parent

    def detach (self):
        self.attach(None)

# window.__str__()
    def __str__ (self):
        return self.wid

# window.__repr__()
    def __repr__ (self):
        return self.wid

# window.set_styles()
    def set_styles (self, styles, active_styles):
        self.inactive_style_markers = generate_style_markers(styles)
        self.inactive_default_style_name = self.inactive_style_markers[None]
        if active_styles is None:
            self.active_style_markers = self.inactive_style_markers
            self.active_default_style_name = self.inactive_default_style_name
        else:
            self.active_style_markers = generate_style_markers(active_styles)
            self.active_default_style_name = self.active_style_markers[None]
        self.style_markers = self.inactive_style_markers
        self.default_style_name = self.inactive_default_style_name

    def select_theme (self, theme, do_refresh = True):
        sm = getattr(self, theme + '_style_markers')
        dsn = getattr(self, theme + '_default_style_name')
        if self.style_markers is sm: return
        self.style_markers = sm
        self.default_style_name = dsn
        if do_refresh: self.refresh()

# window.subwindows()
    def subwindows (self):
        return tuple()

# window._write_updates()
    def _write_updates (self, row, updates):
        if not updates: return
        if not self.parent:
            dmsg('dropping updates from {} because it has no parent', self)
            return
        self.parent.on_child_row_updates(self, row, updates)

# window._write()
    def _write (self, row, col, style_name, text):
        '''
        Adds the given text in the right place in the updates field.
        No need to overload this.
        '''
        self._write_updates(row, (strip(text, style_name, col),))
        #dmsg('win={!r}({}x{}) write strip: row={} col={} style={!r} text={!r}', self, self.width, self.height, row, col, style_name, text)

# window.write()
    def write (self, row, col, style_name, text, clip_col = 0, clip_width = None):
        '''
        Adds the given text taking into account the given clipping coords.
        No need to overload this.
        '''
        # limit clipping coords to window width
        clip_end_col = clip_col + clip_width if clip_width is not None else self.width
        if clip_col < 0: clip_col = 0
        if clip_end_col > self.width: clip_end = self.width
        if clip_col >= clip_end_col: return

        if col < clip_col:
            i = compute_index_of_column(text, clip_col - col)
            if i is None: return
            col = clip_col
            text = text[i:]
        #clip_end_col = clip_col + clip_width if clip_width is not None else self.width
        #if clip_end_col > self.width: clip_end_col = self.width
        if col >= clip_end_col: return
        i = compute_index_of_column(text, clip_end_col - col)
        if i is not None: text = text[:i]
        self._write(row, col, style_name, text)

# window.sfmt()
    def sfmt (self, fmt, *l, **kw):
        '''
        Format text with styles.
        '''
        return fmt.format(*l, **kw, **self.style_markers)

# window.put()
    def put (self, row, col, styled_text, clip_col = 0, clip_width = None):
        #dmsg("************* put self: {}, row: {}, col: {}, clip_col: {}, clip_width: {}", self, row, col, clip_col, clip_width)
        for style, text in styled_text_chunks(styled_text, self.default_style_name):
            self.write(row, col, style, text, clip_col, clip_width)
            col += compute_text_width(text)

# window.set_cursor()
    def set_cursor (self, mode, row = 0, col = 0):
        if not self.in_focus:
            dmsg('{}.set_cursor({}, {}, {}) ignored (unfocused)', self, mode, row, col)
            return
        self._write_updates(row, [cursor_update(mode, row, col)])

# window.update_style()
    def update_style (self, row, col, width, restyler):
        if isinstance(restyler, str):
            restyler = lambda x, y=restyler: y
        self._write_updates(row, (style_update(col, width, restyler),))

# window.refresh_strip()
    def refresh_strip (self, row, col, width):
        '''
        Refreshes the content a strip of the window.
        Overload this to implement displaying content in your window.
        Normally you want to call write() with text to cover all length
        of the given strip.
        This should ideally not do blocking operations as for good UX it must
        be fast.
        '''
        txt = ('.' if row else '-') * (self.width // 2) + '+'
        txt += txt[0] * (self.width - self.width // 2)
        self.write(row, col, 'default', txt[col:col + width])

# window.refresh()
    def refresh (self,
            start_row = 0,
            start_col = 0,
            height = None,
            width = None):
        '''
        Calls refresh_strip() for each row in given range.
        if height or width are left None they will cover the window to its
        border.
        Calling this method without explicit args causes entire window to be
        redrawn.
        No need to overload this.
        '''
        dmsg('win:{} refresh', self)

        if start_row >= self.height or start_col >= self.width: return

        if height is None: height = self.height
        if width is None: width = self.width

        end_row = min(self.height, start_row + height)
        width = min(self.width - start_col, width)

        for r in range(start_row, end_row):
            self.refresh_strip(r, start_col, width)

# window.resize()
    def resize (self, width = None, height = None):
        '''
        Updates window size and refreshes whole content.
        Do not overload this. If you need to adjust internal layout following
        a resize please overload on_resize()
        '''
        if width is None: width = self.width
        if height is None: height = self.height
        self.width = max(0, width)
        self.height = max(0, height)
        dmsg('win:{} resize to {}x{}', self, self.width, self.height)
        if self.width > 0 and self.height > 0:
            self.on_resize(self.width, self.height)

# window.on_resize()
    def on_resize (self, width, height):
        '''
        Overload this if you need more than just a refresh of the content
        '''
        self.refresh()

# window.handle_key()
    def handle_key (self, msg):
        return self.on_key(msg.key)

# window.on_key()
    def on_key (self, key):
        dmsg('{}: received key {}', self, key)
        return False

# window.handle()
    def handle (self, msg):
        '''
        Message handler.
        No need to overload this, instead create/overload methods named
            handle_<message_name>
        '''
        handler_name = 'handle_' + msg.name
        if hasattr(self, handler_name):
            getattr(self, handler_name)(msg)

# window.handle_resize()
    def handle_resize (self, msg):
        '''
        Default handler for window resize!
        '''
        self.resize(msg.width, msg.height)

# window.is_focusable()
    def is_focusable (self):
        return self.can_have_focus

# window.set_focusable()
    def set_focusable (self, focusable = True):
        self.can_have_focus = focusable
        return

# window.focus_to()
    def focus_to (self, win):
        if self is win:
            dmsg('{} focusing!', self)
            self.focus()
            return True
        dmsg('{}.focus_to({}) -> false', self, win)
        return False

# window.focus()
    def focus (self, is_it = True):
        '''
        It can switch from being in focus to out of focus
        if the focusing mechanism is enabled (disabled by default)
        It will always be able to switch out of focus!
        '''
        dmsg('{}: new_focus={} old_focus={} can_focus={}',
                self, is_it, self.in_focus, self.can_have_focus)
        new_focus_state = is_it and self.can_have_focus
        if self.in_focus == new_focus_state:
            dmsg('{}: already in focus={}', self, new_focus_state)
            return
        dmsg('{}.focus = {}. state: {!r}', self, new_focus_state, self)
        self.in_focus = new_focus_state
        self.on_focus_change()

# window.on_focus_change()
    def on_focus_change (self):
        '''
        Called when focus state changes.
        Can override this or override both on_focus_enter(), on_focus_leave()
        '''
        if self.in_focus:
            self.on_focus_enter()
        else:
            self.on_focus_leave()

# window.on_focus_enter()
    def on_focus_enter (self):
        self.select_theme('active')

# window.on_focus_leave()
    def on_focus_leave (self):
        self.select_theme('inactive')

# window.input_timeout()
    def input_timeout (self):
        '''
        Calls on_input_timeout on self.
        '''
        dmsg('{}.input_timeout()', self)
        self.on_input_timeout()

# window.on_input_timeout()
    def on_input_timeout (self):
        '''
        Overload this to handle input timeout.
        If a window has subwindows overload this to pass down to subwindows.
        '''
        return

# class window - end

#* container ****************************************************************
class container (window):
    '''
    Container for storing multiple windows on a direction (h/v).
    '''

    HORIZONTAL = 0
    VERTICAL = 1
    item = zlx.record.make('container.item', 'window weight min_size max_size concealed index focusable_index pos size')

# container.__init__()
    def __init__ (self, direction = VERTICAL, wid = None):
        window.__init__(self, wid = wid, can_have_focus = True)
        assert direction in (container.HORIZONTAL, container.VERTICAL)
        self.direction = direction
        self.items_ = []
        self.win_to_item_ = {}
        self.focusable_items_ = []
        self.focused_item = None

# container.__repr__()
    def __repr__ (self):
        return '{}(focus_idx={}, items={!r})'.format(self, self.focused_item.index if self.focused_item else -1, self.items_)

# container.subwindows()
    def subwindows (self):
        for item in self.items_:
            yield item.window
        return

# container._update_item_indices()
    def _update_item_indices (self, start = 0):
        for i in range(start, len(self.items_)):
            self.items_[i].index = i

# container._update_focusable_item_indices()
    def _update_focusable_item_indices (self, start = 0):
        for i in range(start, len(self.focusable_items_)):
            self.items_[i].focusable_index = i

# container._compute_focusable_index_from_index()
    def _compute_focusable_index_from_index (self, index):
        '''
        given an index calculate what position should this be in the focusable item list
        '''
        for fx in range(len(self.focusable_items_)):
            if index <= self.focusable_items_[fx].index:
                return fx
        return len(self.focusable_items_)

# container._add_focusable_item()
    def _add_focusable_item (self, item):
        item.focusable_index = self._compute_focusable_index_from_index(item.index)
        self.focusable_items_.insert(item.focusable_index, item)
        self._update_focusable_item_indices(item.focusable_index + 1)
        dmsg('{}.focusable_items: {!r}', self, self.focusable_items_)

# container._del_focusable_item()
    def _del_focusable_item (self, item):
        assert self.focusable_items_[item.focusable_index] is item
        del self.focusable_items_[item.focusable_index]
        self._update_focusable_item_indices(item.focusable_index)
        dmsg('{}.focusable_items: {!r}', self, self.focusable_items_)

# container.add()
    def add (self, win, index = None, weight = 1, min_size = 1, max_size = 65535, concealed = False):
        assert weight > 0
        assert min_size <= max_size

        if index is None: index = len(self.items_)
        item = container.item(win, weight, min_size, max_size, concealed, index)
        dmsg('{}.add({!r})', self, item)
        self.items_.insert(index, item)
        self.win_to_item_[win] = item
        self._update_item_indices(index + 1)

        win.attach(self)
        if not concealed:
            if win.is_focusable():
                self._add_focusable_item(item)
            self.resize()

        dmsg('state after container.add(): {!r}', self)
        return item

# container.on_child_row_updates()
    def on_child_row_updates (self, child, row, update_list):
        item = self.win_to_item_[child]
        r, c = self._get_item_row_col(item)
        if c is None:
            # position not yet computed
            return
        ul = []
        for u in update_list:
            if isinstance(u, strip):
                ul.append(strip(u.text, u.style_name, u.col + c))
            elif isinstance(u, cursor_update):
                ul.append(cursor_update(u.mode, u.row + r, u.col + c))
            elif isinstance(u, style_update):
                ul.append(style_update(u.col + c, u.width, u.restyler))
            else:
                raise error("boo")
        self._write_updates(row + r, ul)

# container.set_item_visibility()
    def set_item_visibility (self, win, visible = True, toggle = False):
        '''
        returns true if it should lose focus
        '''
        lose_focus = False
        item = self.win_to_item_[win]
        if toggle:
            concealed = not item.concealed
        else:
            concealed = not visible
        if item.concealed == concealed:
            dmsg('{}.set_item_visibility({},v={},t={}) => leaving {} unchanged',
                    self, win, visible, toggle, win)
            return lose_focus

        # if concealing focused item, move focus
        if self.focused_item is item and concealed:
            if len(self.focusable_items_) == 1:
                lose_focus = True
                dmsg('{} concealing focused item {!r} => request losing focus!',
                        self, item)
            else:
                dmsg('{}.set_item_visibility({}) => concealing focused item... cycle focus',
                        self, win)
                dmsg('state: {!r}', self)
                self.cycle_focus(in_depth = False, wrap_around = True)
        if concealed: self._del_focusable_item(item)
        else: self._add_focusable_item(item)

        dmsg('{}.set_item_visibility({}) => visible={}, resizing...',
                self, win, not concealed)
        item.concealed = concealed
        self.resize()
        if self.focused_item is item:
            # there was only this item in the contained and had focus
            # cycle_focus returned the focus back to this
            # we have to tell caller to change focus to something else
            self.focused_item = None
            return True
        return False

# container._locate_item_by_pos()
    def _locate_item_by_pos (self, pos):
        for i in range(len(self.items_)):
            item = self.items_[i]
            if pos >= item.pos and pos - item.pos < item.size:
                return (item, i)
        return (None, None)

# container.del_at_index()
    def del_at_index (self, idx):
        parent_refocus = False
        if idx >= len(self.items_): raise error('boo')
        item = self.items_[idx]
        item.win.detach()
        assert item.index == idx
        if self.focused_item is item:
            self.cycle_focus(in_depth = False, wrap_around = True)
            if self.focused_item is item:
                self.focused_item = None
                parent_refocus = True
        del self.items_[idx]
        assert self.focusable_items_[item.focusable_index] == item
        del self.focusable_items_[item.focusable_index]
        self._update_item_indices(idx)
        self._update_focusable_item_indices(item.focusable_index)
        return parent_refocus

# container.is_horizontal()
    def is_horizontal (self):
        return self.direction == container.HORIZONTAL

# container.is_vertical()
    def is_vertical (self):
        return self.direction == container.VERTICAL

# container._forget_item_locations()
    def _forget_item_locations (self):
        for item in self.items_:
            item.pos = 0
            item.size = 0

# container._compute_weight_of_unsized_items()
    def _compute_weight_of_unsized_items (self):
        weight = 0
        for item in self.items_:
            if item.concealed: continue
            weight += item.weight
        return weight

# container._compute_min_size()
    def _compute_min_size (self):
        min_size = 0
        for item in self.items_:
            if item.concealed: continue
            min_size += item.min_size
        return min_size

# container._compute_position_of_items()
    def _compute_position_of_items (self):
        pos = 0
        for item in self.items_:
            item.pos = pos
            pos += item.size
        dmsg('{}.items: {!r}', self, self.items_)

# container.is_focusable()
    def is_focusable (self):
        return self.can_have_focus and self.focusable_items_

# container._get_item_row_col()
    def _get_item_row_col (self, item):
        if self.is_vertical(): return (item.pos, 0)
        elif self.is_horizontal(): return (0, item.pos)

# container.on_focus_leave()
    def on_focus_leave (self):
        dmsg('{}.on_focus_leave: focused={!r}', self, self.focused_item)
        if self.focused_item:
            item = self.focused_item
            item.window.focus(False)

# container.on_focus_enter()
    def on_focus_enter (self):
        dmsg('{}.on_focus_enter', self)
        if self.focused_item is None:
            self.cycle_focus()
        else:
            item = self.focused_item
            item.window.focus()

# container.focus_to()
    def focus_to (self, win):
        dmsg('{}: requested to focus on {}', self, win)
        if window.focus_to(self, win): return True
        dmsg('trying to focus on sub-items: {!r}', self.focusable_items_)
        for item in self.focusable_items_:
            if item.window.focus_to(win):
                dmsg('{}: item #{!r} focused! prev_focused={!r}',
                        self, item, self.focused_item)
                if self.focused_item and self.focused_item is not item:
                        self.focused_item.window.focus(False)
                self.focused_item = item
                dmsg('{}.focused_item = {!r}', self, item)
                self.in_focus = True
                return True
        return False

# container.cycle_focus()
    def cycle_focus (self, in_depth = True, wrap_around = False):
        dmsg('{}.cycle_focus: focused_item={!r}', self, self.focused_item)
        if self.focused_item:
            item = self.focused_item
            if in_depth and hasattr(item.window, 'cycle_focus'):
                dmsg('{}: try cycle_focus on subitem: {!r}', self, item)
                if item.window.cycle_focus(in_depth = True):
                    return True
            dmsg('{} - remove focus for {!r}', self, item)
            item.window.focus(False)
        s = self.focused_item.focusable_index + 1 if self.focused_item else 0
        dmsg('s={}', s)
        if s >= len(self.focusable_items_):
            if wrap_around: s = 0
        dmsg('s={}', s)
        if s >= len(self.focusable_items_):
            self.focused_item = None
            dmsg('abandon focus')
            return False
        self.focused_item = self.focusable_items_[s]
        self.focused_item.window.focus(True)
        return True

# container._size_to_weight_height()
    def _size_to_weight_height (self, size):
        if self.direction == container.HORIZONTAL: return (size, self.height)
        elif self.direction == container.VERTICAL: return (self.width, size)
        else: raise error('bad dir: {}', self.direction)

# container.on_resize()
    def on_resize (self, width, height):
        if self.direction == container.HORIZONTAL: size = width
        elif self.direction == container.VERTICAL: size = height
        else: raise error('bad dir: {}', self.direction)

        self._forget_item_locations()
        min_size = self._compute_min_size()
        dmsg('{} resize({}x{}): min_size={} size={}',
                self, width, height, min_size, size)
        if size < min_size and self.focused_item:
            self.focused_item.size = min(size, self.focused_item.max_size)

        items_to_place = [item for item in self.items_ if not item.concealed]
        items_to_place.sort(key = lambda item: item.max_size - item.min_size)

        total_weight = self._compute_weight_of_unsized_items()
        for item in items_to_place:
            dmsg('{}: {!r} => iw={} tw={}', self, item, item.weight, total_weight)
            item.size = saturate(round(size * item.weight / total_weight), item.min_size, item.max_size)
            size -= item.size
            total_weight -= item.weight

        self._compute_position_of_items()

        lp = 0
        for item in self.items_:
            if item.concealed: continue
            wh = self._size_to_weight_height(item.size)
            dmsg('{}: resizing {!r} to {}', self, item, wh)
            item.window.resize(*wh)
            rc = self._get_item_row_col(item)
            lp = item.pos + item.size

        #if lp < size: self.refresh()

        return

# container.input_timeout()
    def input_timeout (self):
        self.on_input_timeout()
        for item in self.items_:
            item.window.input_timeout()

# container.refresh_strip()
    def refresh_strip (self, row, col, width):
        dmsg('{}.refresh_strip(row={}, col={}, width={})', self, row, col, width)
        if self.is_vertical():
            item, idx = self._locate_item_by_pos(row)
            if item:
                item.window.refresh(row - item.pos, col, 1, width)
                return
        elif self.is_horizontal():
            item, idx = self._locate_item_by_pos(col)
            end_col = col + width
            while col < end_col and item:
                w = min(item.size, width)
                item.window.refresh(row, col - item.pos, 1, w)
                col += item.size
                width -= w
                idx += 1
                item = self.items_[idx] if idx < len(self.items_) else None
            # if not covered 'til end fall in the default window refresh
        if width:
            window.refresh(self, row, col, 1, width)
        return

# container.pre_key()
# Overload this if your container needs to process keys before sending them to children
    def pre_key (self, key):
        return False

# container.post_key()
# Overload this if your container needs to process keys unprocessed by its children
    def post_key (self, key):
        return False

# container.on_key()
    def on_key (self, key):
        if self.pre_key(key):
            return True

        if self.focused_item:
            key_handled = self.focused_item.window.on_key(key)
        else:
            dmsg('{}: dropping {!r} due to unfocused item', self, msg)
            key_handled = True

        if not key_handled:
            key_handled = self.post_key(key)

        return key_handled

# class container - end

#* vcontainer ***************************************************************
def vcontainer (**b):
    return container(direction = container.VERTICAL, **b)

#* hcontainer ***************************************************************
def hcontainer (**b):
    return container(direction = container.HORIZONTAL, **b)

#* cc_window ****************************************************************
class cc_window (window):
    '''
    Cached-content window.
    This window caches the content that needs displaying.
    When refresh() or refresh_strip() is called it just
    provides the relevant portion of the cache.
    '''

# cc_window.__init__()
    def __init__ (self,
            wid = None,
            init_content = None,
            styles = 'default',
            active_styles = None,
            can_have_focus = False):
        window.__init__(self,
                wid = wid,
                can_have_focus = can_have_focus,
                styles = styles,
                active_styles = active_styles)
        self.content = []
        self.top_row = 0
        self.auto_scroll = True
        if init_content: self.set_content(0, init_content)

# cc_window.general_out()
    def general_out (self, text):
        self.set_content(len(self.content), text)

# cc_window.set_content()
    def set_content (self, row, text):
        '''updates the cached content. No need to overload this!'''
        l = text.splitlines()
        while row > len(self.content):
            self.content.append('')
        self.content[row : row + len(l)] = l
        if self.height > 0 and self.auto_scroll and len(self.content) > self.height:
            self.top_row = len(self.content) - self.height
        dmsg('got content:\n{}', '\n'.join([repr(x) for x in self.content]))
        self.refresh()

# cc_window.scroll()
# If the window has a height then we can scroll its contents up and down
# while disabling the auto_scroll at the same time
    def scroll (self, delta):
        if self.height > 0:
            tmp_top_row = self.top_row + delta
            if tmp_top_row < 0 or len(self.content) <= self.height:
                tmp_top_row = 0
            if len(self.content) > self.height and tmp_top_row > (len(self.content) - self.height):
                tmp_top_row = len(self.content) - self.height
            self.auto_scroll = False
            self.top_row = tmp_top_row
            self.refresh()

# cc_window.auto_scroll_on()
# enable auto-scrolling capability
    def auto_scroll_on (self):
        if self.height > 0:
            if len(self.content) <= self.height:
                self.top_row = 0
            else:
                self.top_row = len(self.content) - self.height
        self.auto_scroll = True
        self.refresh()

# cc_window.refresh_strip()
    def refresh_strip (self, row, col, width):
        #dmsg('cc_win: refresh row={} col={} width={}', row, col, width)
        logical_row = self.top_row + row
        if logical_row >= 0 and logical_row < len(self.content):
            txt = self.sfmt(self.content[logical_row])
        else:
            txt = ''
        #dmsg('{}: cc_win: refresh_strip with {!r}', self, txt)
        w = compute_styled_text_width(txt)
        if w < self.width: txt += self.sfmt(' ' * (self.width - w))
        self.put(row, 0, txt, clip_col = col, clip_width = width)

# cc_window.regenerate_content()
    def regenerate_content (self):
        '''
        Overload this if reflowing text is needed
        '''
        pass

# cc_window.on_resize()
    def on_resize (self, width, height):
        self.regenerate_content()
        # if we don't have a fixed top row then we recalculate it at every resize
        if self.auto_scroll and height > 0 and len(self.content) > height:
            self.top_row = len(self.content) - height

        self.refresh()

# end cc_window

#* simple_doc_window ********************************************************
class simple_doc_window (window):

    def __init__ (self,
            wid = None,
            styles = 'default',
            active_styles = None,
            doc_fmt = '',
            doc_kwargs = {},
            can_have_focus = True):
        window.__init__(self,
                wid = wid,
                styles = styles,
                active_styles = active_styles,
                can_have_focus = can_have_focus)
        self.set_doc(doc_fmt, **doc_kwargs)
        self.display_top_row = 0

    def _reset_content (self):
        self.content_ = []
        self.last_row_ = []
        self.last_row_width_ = 0
        self.content_.append(self.last_row_)

    def _fill_to_eol (self, fill_char = ' '):
        if self.last_row_width_ < self.width:
            self.last_row_.append(
                strip(fill_char * (self.width - self.last_row_width_),
                    self.default_style_name, self.last_row_width_))
            self.last_row_width_ = self.width


    def _new_row (self, fill_char = ' '):
        self._fill_to_eol(fill_char)
        self.last_row_ = []
        self.last_row_width_ = 0
        self.content_.append(self.last_row_)

    def _add_text (self, text, style = None):
        if style is None:
            style = self.last_row_[-1].style_name
        if self.last_row_ and self.last_row_[-1].style_name == style:
            self.last_row_[-1].text += text
        else:
            self.last_row_.append(strip(text, style, self.last_row_width_))
        self.last_row_width_ += compute_text_width(text)

    def _justify_last_row (self):
        dmsg('enter justifying: {!r}', self.last_row_)
        dmsg('width={}', self.last_row_width_)
        while self.last_row_width_ < self.width:
            skip_start_ws = True
            col = 0
            n = self.width - self.last_row_width_
            for s in self.last_row_:
                dmsg('justifying: {!r}, n={}', s.text, n)
                s.col = col
                tl = []
                for ch in s.text:
                    tl.append(ch)
                    if ch.isspace():
                        if skip_start_ws: continue
                        if n:
                            dmsg('insert space')
                            tl.append(' ')
                            n -= 1
                    else:
                        #dmsg('skip_ws off')
                        skip_start_ws = False
                s.text = ''.join(tl)
                dmsg('justified: {!r}', s.text)
                col += compute_text_width(s.text)
            dmsg('new width: {}', col)
            if col == self.last_row_width_:
                # could not insert any space, give up
                break
            self.last_row_width_ = col
        dmsg('exit justifying: {!r}', self.last_row_)
        return



    STYLE_CMDS = dict(
            par = ''.join((STYLE_BEGIN, 'paragraph', STYLE_END)),
            br = ''.join((STYLE_BEGIN, 'br', STYLE_END)),
            hr = ''.join((STYLE_BEGIN, 'hr', STYLE_END)),
            cpar = ''.join((STYLE_BEGIN, 'continue-paragraph', STYLE_END)),
            justify = ''.join((STYLE_BEGIN, 'justify', STYLE_END)),
            no_justify = ''.join((STYLE_BEGIN, 'no_justify', STYLE_END)),
            verbatim = ''.join((STYLE_BEGIN, 'verbatim', STYLE_END)),
            code = ''.join((STYLE_BEGIN, 'verbatim', STYLE_END)),
            pre = ''.join((STYLE_BEGIN, 'pre', STYLE_END)),
            indent = ''.join((STYLE_BEGIN, 'indent', STYLE_END)),
            tab = ''.join((STYLE_BEGIN, 'indent', STYLE_END)),
            wrap_indent = ''.join((STYLE_BEGIN, 'wrap_indent', STYLE_END)),
            )
    def _render (self):
        if self.width < 1: return
        self.empty_row_strips_ = [strip(' ' * self.width, self.default_style_name, 0)]
        self._reset_content()
        doc = self.doc_fmt.format(**self.STYLE_CMDS, **self.doc_kwargs, **self.style_markers)
        mode = 'verbatim'
        current_style = self.default_style_name
        wrap_indent = 0
        justify = False
        for style, text in styled_text_chunks(doc, self.default_style_name):
            if style == 'verbatim':
                mode = 'verbatim'
            elif style == 'pre':
                mode = 'verbatim'
                self._new_row()
            elif style == 'continue-paragraph':
                mode = 'paragraph'
            elif style == 'paragraph':
                mode = 'paragraph'
                wrap_indent = 0
                justify = False
                self._new_row()
            elif style == 'br':
                self._new_row()
                mode = 'paragraph'
            elif style == 'hr':
                if self.last_row_width_ > 0:
                    self._new_row()
                self._new_row('-')
            elif style == 'wrap_indent':
                wrap_indent = int(text)
                continue
            elif style == 'justify':
                justify = True
            elif style == 'no_justify':
                justify = False
            elif style == 'indent':
                n = int(text)
                m = (self.last_row_width_ + n) // n * n
                if m >= self.width:
                    self._new_row()
                    o = n
                else:
                    o = m - self.last_row_width_
                self._add_text(' ' * o, current_style)
                continue
            else:
                current_style = style
            if mode == 'verbatim':
                while text:
                    if '\n' in text:
                        t, r = text.split('\n', 1)
                        self._add_text(t, current_style)
                        self._new_row()
                        text = r
                    else:
                        self._add_text(text, current_style)
                        break
            elif mode == 'paragraph':
                first_para = True
                text += '\x01'
                for paragraph in text.split('\n\n'):
                    first = True
                    if first_para:
                        first_para = False
                    else:
                        self._new_row()
                    for text_chunk in paragraph.split():
                        if text_chunk.endswith('\x01'):
                            text_chunk = text_chunk[:-1]
                        tw = compute_text_width(text_chunk)
                        spc = 0 if first else 1
                        first = False
                        if self.last_row_width_ + tw + spc <= self.width:
                            if spc:
                                self._add_text(' ', current_style)
                            self._add_text(text_chunk, current_style)
                            continue
                        if wrap_indent + tw <= self.width:
                            if justify:
                                self._justify_last_row()
                            self._new_row()
                            if wrap_indent:
                                self._add_text(' ' * wrap_indent, current_style)
                            self._add_text(text_chunk, current_style)
                            continue
                        if spc:
                            if self.last_row_width_ and self.last_row_width_ + 1 + spc <= self.width:
                                self._add_text(' ')
                            else:
                                self._new_row()
                        while text_chunk:
                            i = compute_index_of_column(text_chunk, self.width - self.last_row_width_)
                            if i is None: i = len(text_width)
                            self._add_text(text_chunk[:i], current_style)
                            text_chunk = text_chunk[i:]
                            if self.last_row_width_ == self.width:
                                self._new_row()
                pass
        self._fill_to_eol()

    def on_resize (self, width = None, height = None):
        self._render()
        self.refresh()

# simple_doc_window.on_focus_enter()
    def on_focus_enter (self):
        self.select_theme('active', do_refresh = False)
        self._render()
        self.refresh()

# simple_doc_window.on_focus_leave()
    def on_focus_leave (self):
        self.select_theme('inactive')
        self._render()
        self.refresh()

    def set_doc (self, fmt, **kwargs):
        self.doc_fmt = fmt
        self.doc_kwargs = kwargs
        self._render()

# simple_doc_window.refresh_strip()
    def refresh_strip (self, row, col, width):
        r = self.display_top_row + row
        if r >= 0 and r < len(self.content_):
            self._write_updates(row, trim_strips(self.content_[r], col, width))
        else:
            self._write(row, col, self.default_style_name, ' ' * width)



#* input_line ***************************************************************
class input_line (window):

# input_line.__init__()
    def __init__ (self,
            styles,
            active_styles = None,
            accept_text_func = lambda text: text,
            cancel_text_func = lambda : None,
            cursor_mode = CM_NORMAL):
        window.__init__(self,
                styles = styles,
                active_styles = active_styles,
                can_have_focus = True)
        self.text = ''
        self.pos = 0
        self.accept_text_func = accept_text_func
        self.cancel_text_func = cancel_text_func
        self.cursor_mode = CM_NORMAL

# input_line.refresh_strip()
    def refresh_strip (self, row, col, width):
        if row != 0:
            window.refresh_strip(self, row, col, width)
            return
        t = self.text
        self.put(row, 0, t, clip_col = col, clip_width = width)
        self.put(row, len(t), ' ' * max(0, self.width - len(t)), clip_col = col, clip_width = width)
        if self.pos >= col and self.pos - col < width:
            self.set_cursor(self.cursor_mode, 0, self.pos)

    def erase_text (self):
        if len(self.text):
            self.text = ''
            self.pos = 0
            self.refresh()

# input_line.on_key()
    def on_key (self, key):
        if key in ('Ctrl-A', 'Home'):
            if self.pos > 0:
                self.pos = 0
                self.set_cursor(self.cursor_mode, 0, self.pos)
            return True
        if key in ('Ctrl-B', 'Left'):
            if self.pos > 0:
                self.pos -= 1
                self.set_cursor(self.cursor_mode, 0, self.pos)
            return True
        if key in ('Backspace',):
            if self.pos > 0:
                self.pos -= 1
                self.text = self.text[0 : self.pos] + self.text[self.pos + 1 : 0]
                self.refresh()
            return True
        if key in ('Ctrl-F', 'Right'):
            if self.pos < len(self.text):
                self.pos += 1
                self.set_cursor(self.cursor_mode, 0, self.pos)
            return True
        if key in ('Ctrl-E', 'End'):
            if self.pos < len(self.text):
                self.pos = len(self.text)
                self.set_cursor(self.cursor_mode, 0, self.pos)
            return True
        if key in ('Ctrl-U',):
            if self.text:
                self.text = self.text[self.pos : ]
                self.pos = 0;
                self.refresh()
            return True
        if key in ('Ctrl-K',):
            if self.text and self.pos < len(self.text):
                self.text = self.text[0 : self.pos]
                self.refresh()
            return True
        if key in ('Enter',):
            self.on_accept_text()
            self.refresh()
            return True
        if key in ('Esc',):
            self.on_cancel()
            self.refresh()
            return True
        else:
        #if len(key) == 1:
            self.text = self.text[0 : self.pos] + key + self.text[self.pos : ]
            self.pos += len(key)
            self.refresh()
            return True
        return False

# input_line.on_accept_text()
    def on_accept_text (self):
        '''
        Called when Enter is pressed while having focus.
        '''
        self.accept_text_func(self.text)

    def on_cancel (self):
        '''
        Called when input is cancelled (Esc is pressed).
        '''
        self.cancel_text_func()

#* application **************************************************************
class application (window):
    '''
    Represents a Text UI application.
    This class represents the root window of the app plus a way of
    describing the styles that are used when displaying text
    Derive to taste.
    Recommended overloads:
    - generate_style_map() - to generate style according to driver's capabilities
    - various message handlers: handle_xxx() (handle_timeout, handle_char)
    - refresh_strip() - to generate output for a row portion when asked
    '''

# application.__init__()
    def __init__ (self):
        '''
        Initializes the root window.
        Overload this!
        '''
        window.__init__(self)
        self.updates = {}

# application.generate_style_map()
    def generate_style_map (self, style_caps):
        '''
        Produces a mapping name -> style where styles should be adapted
        to given capabilities.
        Normally this is called when the app is getting connected to a driver
        after obtaining the style capabilities of the driver.

        '''
        default_style = style(
                attr = A_NORMAL,
                fg = style_caps.fg_default,
                bg = style_caps.bg_default)
        return dict(default = default_style)

# application.wipe_updates()
    def wipe_updates (self):
        '''
        Empties the strips from the updates field.
        No need to overload this.
        '''
        self.updates = {}

# application.fetch_updates()
    def fetch_updates (self):
        '''
        Extracts the updates from this window.
        No need to overload this
        '''
        u = self.updates
        self.wipe_updates()
        dmsg('updates: {!r}', u)
        return u

# application on_child_row_updates()
    def on_child_row_updates (self, child, row, update_list):
        #dmsg('app={} row={} updates={!r}', self, row, update_list)
        if row not in self.updates:
            ur = []
        else:
            ur = self.updates[row]
        for u in update_list:
            if isinstance(u, style_update):
                ur = apply_style_update(ur, u.col, u.width, u.restyler)
            else:
                ur.append(u)
        self.updates[row] = ur

# application.loop()
    def loop (app, drv):
        '''
        Uses the given driver to display the app and receives events from it.
        No need to overload this.
        '''
        try:
            drv.register_styles(app.generate_style_map(drv.get_style_caps()))
            ss = drv.get_screen_size()
            app.resize(width = ss.width, height = ss.height)
            while True:
                drv.render(app.fetch_updates())
                app.handle(drv.get_message())
        except app_quit as e:
            return e.ret_code

# application.handle_timeout()
    def handle_timeout (self, msg):
        self.input_timeout()

# class application - end

#* run **********************************************************************
def run (driver_runner, app):
    return driver_runner(lambda drv, app = app: app.loop(drv))

